#import "PAT.Lib.IndexURLTree";
#import "PAT.Lib.Lists";

#define BUFFER_SIZE 3;
#define NUM_BUFFERS 2;

var tree = new IndexURLTree();
var result = [0,1,2];

var<Lists> buffers = new Lists(NUM_BUFFERS);

// Initialise each queue with some seed urls
// a, b, c ... are just placeholder because of syntax
var a = buffers.Append(0, [0, 1, 2]);
var b = buffers.Append(1, [0, 1, 2]);
var urlPolled = [-1(NUM_BUFFERS)];
var fileExist = [-1(NUM_BUFFERS)];

startAddUrlAndContent(i) = checkIfListEmpty(i);
checkIfListEmpty(i) = [!buffers.isListEmpty(i)] listNotEmpty.i -> getUrlFromBuffer(i) [] [buffers.isListEmpty(i)] listEmpty.i -> Skip;
getUrlFromBuffer(i) = getUrl.i{urlPolled[i] = buffers.PollFromList(i)}  -> checkIfExistInTree(i, urlPolled[i]);
checkIfExistInTree(i, url) = [tree.FileExists(url)==false] makeDirectory.i -> createNewFileAtomic(i, url) [] [tree.FileExists(url)==true] afterAddUrl(i);
createNewFileAtomic(i, url) = [tree.FileExists(url)==false] createFile.i.url{tree.CreateFile(url)} -> writeDataToFile(i,url) [] [tree.FileExists(url)==true] afterAddUrl(i); // If createNewFile is not atomic, will have duplicates. 
// createNewFileNonAtomic(i, url) = nothingForNow; // If createNewFile is not atomic, will have duplicates. 
writeDataToFile(i, url) = writeData.i.url{tree.WriteData(url)} -> afterAddUrl(i);
afterAddUrl(i) = restart.i -> checkIfListEmpty(i);

#define noDuplicateFileCreation (true == !tree.FileListDuplicateExists());
#define noDuplicateDataWrite (true == !tree.DataListDuplicateExists());
#define correct (true == tree.CheckCorrectness(result));

System = |||i:{0..1} @ startAddUrlAndContent(i);

#assert System deadlockfree;
#assert System |= [] noDuplicateFileCreation;
#assert System |= [] noDuplicateDataWrite;
#assert System |= <> correct;
//#assert System reaches goal;
//#assert System reaches goal2;


//1) IUT C# data structure (maybe an array, can refer to the prof email)
//2) IUT check for duplicate
//3) IBT transfer urls from buffer to tree





 